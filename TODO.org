* test qAnd
* test new alternate modes
* use sets
* QNot 
** 1st iteration
:- type qCond ---> qNot( int ) ; ...
checkQCond( qNot(Int), Elt, Res ) :-
  Res = (if ( Elt \= Int )
        then yes else no).
:- func testQNot = bool.
testQNot = Res :-
    checkQCond( qNot(1), 1, Res1 )
  , checkQCond( qNot(1), 0, Res0 )
  , Res = (if [Res1, Res0] = [no,yes] then yes else no).
test.main ...
  io.write_string( "testQNot: "  \++ string(testQNot)  ++ "\n", !IO).
  % that \++ is just ++ to avoid strikethrough
** 2nd : QNot should hold an entire Query
* types
Index = Arity = Int
Expr :: Word String
  | Rel -- ^ connects to a template and to arity exprs(likely not templates).
  | Template -- ^ connects to arity exprs(likely all words).
Role :: RoleTemplate | RoleMember Int
Position = (Index of rel, Role) -- ^ "of rel", etc. : not enforced by types
  -- (This is like a position at an employer: it includes host and role.)
ExprImg :: Index
  | ImgWord String
  | ImgRel ImgExpr [ImgExpr] -- ^ first arg should be of a template
  | ImgTemplate [ImgExpr]
* functions
  arity :: ExprImg -> Index -- ^ words have arity 0. others require counting.
  indexMap :: ExprImg -> Index
  containerMap :: Index -> Set Position -- ^ what hold(s) it
  memberMap :: Position -> Index -- what it holds
