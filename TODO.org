* test qAnd (paused)
* ? test new alternate modes
If the test works one way, and the other mode signatures compile, doesn't it work?
* why doesn't this alternate definition of passesAllChecks work?
** in query.m
:- pred passesAllChecks2( list(qCond), int       ).
:- mode passesAllChecks2( in,          in        ) is semidet.
:- pred passesAllChecks2( list(qCond), int, bool ) is det.
:- mode passesAllChecks2( in,          in,  out  ) is det.

passesAllChecks2( Qs, Elt ) :-
  list.all_true( (pred( Q :: in ) is semidet :- checkQCond( Q, Elt ) )
               , Qs ).
passesAllChecks2( Qs, Elt, Res ) :-
  Res = (if passesAllChecks2( Qs, Elt ) then yes else no).
** in test.m
:- func testPassesAllChecks2 = list(bool).
testPassesAllChecks2 = [T1, T3, T5] :-
    Checks = [ qCond( func( Int ) = (if Int > 2 then yes else no) )
             , qCond( func( Int ) = (if Int < 4 then yes else no) ) ]
  , passesAllChecks2( Checks, 1, T1 )
  , passesAllChecks2( Checks, 3, T3 )
  , passesAllChecks2( Checks, 5, T5 ).

test.main ...
  , io.write_string( "testPassesAllChecks2: "
      ++ string(testPassesAllChecks2) ++ "\n", !IO)
* use sets
* QNot 
** 1st iteration
:- type qCond ---> qNot( int ) ; ...
checkQCond( qNot(Int), Elt, Res ) :-
  Res = (if ( Elt \= Int )
        then yes else no).
:- func testQNot = bool.
testQNot = Res :-
    checkQCond( qNot(1), 1, Res1 )
  , checkQCond( qNot(1), 0, Res0 )
  , Res = (if [Res1, Res0] = [no,yes] then yes else no).
test.main ...
  io.write_string( "testQNot: "  \++ string(testQNot)  ++ "\n", !IO).
  % that \++ is just ++ to avoid strikethrough
** 2nd : QNot should hold an entire Query
* types
Index = Arity = Int
Expr :: Word String
  | Rel -- ^ connects to a template and to arity exprs(likely not templates).
  | Template -- ^ connects to arity exprs(likely all words).
Role :: RoleTemplate | RoleMember Int
Position = (Index of rel, Role) -- ^ "of rel", etc. : not enforced by types
  -- (This is like a position at an employer: it includes host and role.)
ExprImg :: Index
  | ImgWord String
  | ImgRel ImgExpr [ImgExpr] -- ^ first arg should be of a template
  | ImgTemplate [ImgExpr]
* functions
  arity :: ExprImg -> Index -- ^ words have arity 0. others require counting.
  indexMap :: ExprImg -> Index
  containerMap :: Index -> Set Position -- ^ what hold(s) it
  memberMap :: Position -> Index -- what it holds
